#include <iostream>
#include <conio.h>

//POD - like (Plain Old Data) класс
class POD_Class
{
private:
    int m_i;
    double m_d;
public:
    POD_Class() : m_i(0), m_d(0) {}; //Конструктор по умолчанию, заполняет поля нулями
    POD_Class(int i, double d) : m_i(i), m_d(d) {}; //Инициализирующий конструктор, заполняет поля аргументами

    //Метод выводит значения полей
    void print()
    {
        std::cout << "m_i = " << m_i << " m_d = " << m_d << "\n";
    };
};

//Базовый класс
class Base
{
protected:
    int m_i;
    double m_d;
public:
    Base(): m_i(0), m_d(0) {}; //Конструктор по умолчанию, заполняет поля нулями
    Base(int i, double d) : m_i(i), m_d(d) {}; //Инициализирующий конструктор, заполняет поля аргументами

    //Метод базового класса, выводит значения полей
    void print()
    {
        std::cout << "m_i = " << m_i << " m_d = " << m_d << "\n";
    };

    virtual void v_f1() { std::cout << "Av_f1\n"; }; //Виртуальная функция
    void v_f2() { std::cout << "Av_f2\n"; };
};

//Класс наследник от А, тип наследования - public (public и protected члены доступны, privet члены недоступны)
class Derived : public Base
{
private:
    int m_i2;
    double m_d2;
public:
    //Конструктор по умолчанию, вызывает конструктор базового класса
    // (делается автоматом, но желательно прописать),заполняет поля нулями
    Derived(): Base(), m_i2(0), m_d2(0) {};

    //Метод класса наследника, выводит значения полей
    void print2()
    {
        std::cout << "m_i = " << m_i << " m_d = " << m_d << "m_i2 = " << m_i2 << " m_d2 = " << m_d2 << "\n";
    };

    //Переопределенная функция из базового класса
    //Зачем писать override:
    //Если ошибиться в сигнатуре(например, другой тип параметра, забыли const, другое имя), компилятор выдаст ошибку.
    //    Без override компилятор просто создаст новую, невиртуальную функцию, и полиморфизм сломается — тихо и незаметно.
    //Читаемость кода : сразу ясно, что функция переопределяет базовую.
    void v_f1() override { std::cout << "Bv_f1\n"; };

    //Функция класса наследника. Не была объявлена виртуальной в базовом классе, хотя имеет то же имя
    //! Не переопределение (override), а сокрытие (hiding)
    //! Вызов зависит от типа переменной, а не от реального типа объекта 
    void v_f2() { std::cout << "Bv_f2\n"; };
};

void Part1()
{
    POD_Class a(5, 3.2); //Создали объект класса Base, заполнили его поля значениями 5 и 3.2
    a.print(); //Вызвали метод класса Base, проверили, что поля заполнены
    int* pi = reinterpret_cast<int*>(&a); //Получаем указатель на начало объекта a и трактуем его как указатель на int
    // pi указывает на m_i

    int8_t* pb = reinterpret_cast<int8_t*>(&a); //Получаем побайтовый указатель на начало объекта (для точного смещения)

    //pb += sizeof(void *);
    double* pd = reinterpret_cast<double*>(pb + 8); //Сдвигаемся на 8 байт от начала и трактуем как double*.
    //Предполагается, что m_d начинается с 8 - го байта
    // (после 4 - байтового int + 4 байта выравнивания,
    // потому что double обычно требует 8 - байтового выравнивания)
    pi[0] = 7; //Меняем m_i - private(!!!) поле класса, напрямую через int*
    pd[0] = 1.5; //Меняем m_d - private(!!!) поле класса, напрямую через double*
    a.print(); //Проверяем, что поля изменились

    //Выводы этого блока:
    //1. Инкапсуляция в C++ — это логическая, а не физическая защита
    //   Ключевые слова private / protected проверяются только на этапе компиляции.
    //   → На этапе выполнения ничто не мешает читать / писать в память объекта напрямую.
    //2. Объект — это просто блок памяти
    //   Поля класса хранятся в памяти в определённом порядке(с учётом выравнивания),
    //    и к ним можно получить доступ, зная их смещение.
    //3. Опасность reinterpret_cast
    //   Такой код непереносим : порядок полей, выравнивание и размеры типов зависят от компилятора,
    //    архитектуры и опций сборки.
    //   → На другой системе pb + 8 может указывать мимо m_d!

    //!!! Важное замечание:
    //Этот трюк работает только для простых(POD - like (Plain Old Data)) классов:
    // 1. Без виртуальных функций(иначе в начале будет указатель на vtable!),
    // 2. Без наследования(особенно множественного),
    // 3. Без сложных членов(например, std::string).
    //Если бы в классе A была виртуальная функция, то в начале объекта располагался бы указатель
    // на таблицу виртуальных функций(vptr), и тогда весь расчёт смещений сломался бы
}

void Part2()
{
    Base a; //Объект базового класса
    Derived b; //Объект класса наследника

    //Часть 2.1: Полиморфизм
    //Вызываем виртуальную функцию для разных типов объектов.
    //Выполнится метод из того же класса, что и объект
    a.v_f1(); //Av_f1
    b.v_f1(); //Bv_f1

    //Указатель на базовый класс, указывающий на объект производного класса
    Base* pab = &b;
    //Динамическое связывание — основа полиморфизма. Вызывается версия из реального типа объекта
    pab->v_f1(); //Bv_f1

    std::cout << "\n";

    //Часть 2.2: Сокрытие
    //Вызываем обычную функцию для разных типов объектов.
    a.v_f2(); //Av_f2
    b.v_f2(); //Bv_f2
    //Вызов определяется статическим типом переменной(Base*), а не реальным типом объекта.
    //Происходит сокрытие(hiding), а не переопределение
    pab->v_f2(); //Av_f2

    std::cout << "\n";

    //Часть 2.3: Ручная манипуляция с vtable (низкоуровневый хак)
    void* apvVT_B[2]; //Локальный массив
    void*** pppVTa = reinterpret_cast<void***>(&a); //Получаем указатель на адрес vptr объекта a
    void*** ppVTb = reinterpret_cast<void***>(&b);  //Получаем указатель на адрес vptr объекта b
    
    //(*pppVTa)[0] - это адрес vtable класса Base(потому что a — объект Base)
    apvVT_B[0] = (*pppVTa)[0]; //Копируем vtable от Base в локальный массив
    reinterpret_cast<void**>(&b)[0] = apvVT_B; //Перезаписываем vptr объекта b, заставляя его указывать на vtable от Base
    
    pab->v_f1(); //Теперь, несмотря на то что pab указывает на объект Derived,
                 // его vptr ведёт к vtable Base, поэтому вызывается Base::v_f1()!
    
     //!!! Мы вручную "превратили" объект Derived в Base на уровне поведения, не меняя его данных

    std::cout << "\n";
}

int main()
{   
    //Часть 1. Трюк с изменением private поля класса напрямую
    //Part1();

    //Часть 2. Особенности наследования
    Part2();

    return 0;
}
